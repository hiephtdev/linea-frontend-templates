import type { Abi } from 'abitype';
import type { GetErrorArgs, InferErrorName } from 'viem/types/contract.js';
import { type ConcatHexErrorType } from 'viem/utils/data/concat.js';
import { type GetFunctionSelectorErrorType } from 'viem/utils/hash/getFunctionSelector.js';
import type { ErrorType } from 'viem/errors/utils.js';
import { type EncodeAbiParametersErrorType } from 'viem/utils/abi/encodeAbiParameters.js';
import { type FormatAbiItemErrorType } from 'viem/utils/abi/formatAbiItem.js';
import { type GetAbiItemErrorType } from 'viem/utils/abi/getAbiItem.js';
export type EncodeErrorResultParameters<TAbi extends Abi | readonly unknown[] = Abi, TErrorName extends string | undefined = string, _ErrorName = InferErrorName<TAbi, TErrorName>> = {
    errorName?: _ErrorName;
} & (TErrorName extends string ? {
    abi: TAbi;
} & GetErrorArgs<TAbi, TErrorName> : _ErrorName extends string ? {
    abi: [TAbi[number]];
} & GetErrorArgs<TAbi, _ErrorName> : never);
export type EncodeErrorResultErrorType = GetAbiItemErrorType | FormatAbiItemErrorType | GetFunctionSelectorErrorType | EncodeAbiParametersErrorType | ConcatHexErrorType | ErrorType;
export declare function encodeErrorResult<const TAbi extends Abi | readonly unknown[], TErrorName extends string | undefined = undefined>({ abi, errorName, args }: EncodeErrorResultParameters<TAbi, TErrorName>): `0x${string}`;
//# sourceMappingURL=encodeErrorResult.d.ts.map